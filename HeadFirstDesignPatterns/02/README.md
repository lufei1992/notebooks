# 观察者(Observer)模式 
>
- 有一个模式可以帮你的对象知悉现况，不会错过该对象感兴趣的事。对象甚至在运行时可决定是否要继续被通知。
- 观察者模式是JDK中使用最多的模式之一，非常有用。
>
## 认识观察者模式
>
### 出版者+订阅者=观察者模式
>
### 定义观察者模式
>
- 观察者定义了对象之间的一对多依赖，这样依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
>
- 主题和观察者定义了一对多的关系。观察者依赖于此主题，只要主题状态一有变化，观察者就会被通知。根据通知的风格，观察者可能因此新值而更新。
>
### 定义观察者模式：类图
>
- 主题接口(Subject)，对象使用此接口注册为观察者，或者把自己从观察者中删除。
>
- 每个主题可以有许多观察者。
>
- 所有潜在的观察者必须实现观察者接口(Observer)，这个接口只有update()一个方法，当主题状态改变时它被调用。
>
- 一个具体主题总是实现主题接口，除了注册和撤销方法之外，具体主题还实现了notifyObservers()方法，此方法用于在状态改变时更新所有当前观察者。
>
- 具体主题也可能由设置和获取状态的方法。
>
- 具体的观察者可以是实现此接口的任意类。观察者必须注册具体主题，以便接收更新。
>
### 松耦合
>
#### 当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。
>
#### 观察者模式提供了一种对象设计，让主题和观察者之间松耦合。
>
- 
>
### 设计原则
>
#### 为了交互对象之间的松耦合设计而努力。
>
- 松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖性降到了最低。
>
- 
>
### 使用Java内置的观察者模式
>
- java.util包(package)内包含最基本的Observer接口与Observable类，和我们的Subject接口与Observer接口很相似。
>
### Java内置的观察者模式如何运作
>
#### 如何把对象变成观察者
>
- 实现观察者接口(java.util.Observer)，然后调用任何Observable对象的addObserver()方法。不想再当观察者时，调用deleteObserver()方法就可以了。
>
#### 可观察者要如何送出通知
>
- 
>
#### 观察者如何接收通知
>
- 
>
### java.util.Observable的黑暗面
>
#### Observable是一个类
>
#### Observable将关键的方法保护起来
>
- 
>
### 在JDK中，还有哪些地方可以找到观察者模式


